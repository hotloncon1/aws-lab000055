[{"uri":"https://hotloncon1.github.io/aws-lab000055/","title":"Refactor Your Data &amp; Workflows","tags":[],"description":"","content":"Refactor Your Data \u0026amp; Workflows Oveview In this lab we will iterate on our TravelBuddy monolithic implementation, and move it to a serverless/serviceful architecture, with microservices. In previous Labs, we have looked at various serverless concepts - for example, AWS Lambda and Amazon API Gateway - but in this lab, we will rethink our monolith, move to a completely serverless model and incorporate authentication and authorisation using Amazon Cognito.\nYou will take various approaches when deploying the Lambda functions that make up the microservices, from manual deployment to automated CI/CD deployment, to ensure you have a good understanding of each of parts of the architecture, and how infrastructure automation simplifies and streamlines deployment.\nContent: Introduction Preparation Creating A Single Page Application Configure Authentication, Authorization and Accounting (AAA) Tracing Application Performance With AWS X-Ray Challenge Clean up resources "},{"uri":"https://hotloncon1.github.io/aws-lab000055/4-configure-aaa/4.1-add-authentication-with-cognito/","title":"Add Authentication to the SPA using Amazon Cognito User Pools","tags":[],"description":"","content":"Add Authentication to the SPA using Amazon Cognito User Pools In this exercise, we will make use of the Cognito User Pool and Identity Pool, and mark one of our API endpoints as requiring authentication via Cognito User Pools.\nGo to AWS Cognito console. Click User pools Click TravelBuddy Save the User pool ID value Click App integration Save the Client ID value of the App client name whose name is TravelBuddyWebApp Click Federated Identities Click TravelBuddy Click Sample code In the Get AWS Credentials section, save the Identity Pool ID value displayed in the sample code Open the file whose path is www\\scripts\\webapp-configuration.js in the www folder we extracted in step 1 of the 3.5 section The SPA is implemented using the Angular framework, which allows you to define global constants that are used as configuration variables throughout your application. This file defines the values of the configuration variables that you need to set based on your AWS Account’s ARNs and Ids for the various Cognito resources\nReplace REPLACE_WITH_COGNITO_IDENTITY_POOL_ID with the Identity Pool ID value we saved in step 6 Replace REPLACE_WITH_COGNITO_USER_POOL with the User pool ID value we saved in step 2 Replace REPLACE_WITH_COGNITO_USER_POOL_CLIENT_ID with the Client ID value we saved in step 3 Replace REPLACE_WITH_S3_BUCKET_WWW with the S3BucketWWWBucketName value in the Output tab of the DevAx-06 stack In the AWS_REGION field replace with your Region Save Open Command Prompt, navigate to the directory of the www folder we extracted in step 1 in the 3.5 section Execute the following command to upload the changes to the S3BucketWWWBucketName bucket set AWS_PROFILE=devaxacademy aws s3 sync . s3://\u0026lt;S3BucketWWWBucketName\u0026gt; Replace \u0026lt;S3BucketWWWBucketName\u0026gt; with the S3BucketWWWBucketName value in the Output tab of the DevAx-06 stack\n10. Refresh the TravelBuddy web page and check the developer console to confirm there are no errors following the changes you have made.\n"},{"uri":"https://hotloncon1.github.io/aws-lab000055/3-create-single-page-app/3.1-create-dynamodb-table/","title":"Create A DynamoDB Table","tags":[],"description":"","content":"Create A DynamoDB Table populate_tripsector.sh populate_tripsector.sh (1 KB) Download populate_tripsector.sh file to Downloads folder in the Windows virtual machine. Open Command Prompt Execute the below command: set AWS_DEFAULT_PROFILE=devaxacademy cd Downloads populate_tripsector.sh \u0026lt;YOUR_REGION\u0026gt; Replace \u0026lt;YOUR_REGION\u0026gt; by your Region\nGo to AWS DynamoDB Console. Click Explore items Type TravelBuddyTripSectors in the search bar and press Enter Select TravelBuddyTripSectors In Items returned section, You will see 50 records. "},{"uri":"https://hotloncon1.github.io/aws-lab000055/2-prepare/2.1-createkeypair/","title":"Create Key Pair","tags":[],"description":"","content":"Create Key Pair Go to Amazon EC2 console. On the left navigation bar, click Key Pairs. Click Create key pair. In the Create key pair page In the Name section, type KPforDevAxInstances In the Key pair type section, Select RSA In the Private key file format section, select .pem Click Create key pair Save file key pair to use in the next step. "},{"uri":"https://hotloncon1.github.io/aws-lab000055/1-introduction/","title":"Introduction","tags":[],"description":"","content":"Introduction In this lab we will iterate on our TravelBuddy monolithic implementation, and move it to a serverless/serviceful architecture, with microservices. In previous Labs, we have looked at various serverless concepts - for example, AWS Lambda and Amazon API Gateway - but in this lab, we will rethink our monolith, move to a completely serverless model and incorporate authentication and authorisation using Amazon Cognito.\nYou will take various approaches when deploying the Lambda functions that make up the microservices, from manual deployment to automated CI/CD deployment, to ensure you have a good understanding of each of parts of the architecture, and how infrastructure automation simplifies and streamlines deployment.\nThe overall architecture you will build is as follows:\nAmazon Cognito Amazon Cognito lets you easily add user sign-up and sign-in to your mobile and web apps. With Amazon Cognito, you also have the options to authenticate users through social identity providers such as Facebook, Twitter, or Amazon, with SAML identity solutions, or by using your own identity system.\nClick here for more information about Amazon Cognito\nAmazon API Gateway Amazon API Gateway is an AWS service that enables developers to create, publish, maintain, monitor, and secure APIs at any scale. You can create APIs that access AWS or other web services, as well as data stored in the AWS Cloud. API Gateway can be considered a backplane in the cloud to connect AWS services and other public or private web sites. It provides consistent RESTful application programming interfaces (APIs) for mobile and web applications to access AWS services.\nClick here for more information about Amazon API Gateway\nTopics Covered By the end of this lab, you will be able to:\nUnderstand how you can take a monolithic application and distill it down into a Single Page Web Application hosted on Amazon S3, with supporting business logic provided by Amazon API Gateway and AWS Lambda. Single Page Web Application hosted on Amazon S3, with supporting business logic provided by Amazon API Gateway and AWS Lambda Use the AWS Console to create and configure an Amazon Cognito User Pool and Identity Pool for use in your serverless application Manually deploy a Lambda function using the AWS CLI Manually deploy a Lambda function using the AWS CLI CloudFormation tool Manually configure an API in Amazon API Gateway Automate the full deployment of an API using CodeStar Generate SDKs from Amazon API Gateway Technical Knowledge Prerequisites To successfully complete this lab, you should be familiar with basic navigation of the AWS Management Console and have intermediate experience using the Eclipse IDE and the Java Programming language.\nEnvironment All the resources required to begin this lab have already been provisioned and set up for you. If running in your own account, use this CloudFormation template The following diagram depicts the resources that were deployed in your AWS account.\n"},{"uri":"https://hotloncon1.github.io/aws-lab000055/2-prepare/2.2-createstack/","title":"Create a CloudFormation stack","tags":[],"description":"","content":"Create a CloudFormation stack Template File Module6.template.yaml (51 KB) Download file Module6.template.yaml. Go to Amazon CloudFormation Console. Click Stacks Click Create stack. Click With new resources (standard). In the Specify template section. Select Upload a template file Click Choose file, then select file Module6.template.yaml we downloaded. Click Next. In the Stack name section, type DevAx-06. In the Stack name section, seclect KPforDevAxInstances. Click Next. In the Configure stack options page, Drag the screen down, then Click Next. In the Review page. Drag the screen down, then Click I acknowledge that AWS CloudFormation might create IAM resources with custom names. Click Create stack. Cloudformation will take 5 minutes to deploy Web App. Wait until all stacks are shown in a CREATE_COMPLETE state.\n"},{"uri":"https://hotloncon1.github.io/aws-lab000055/3-create-single-page-app/3.2-build-and-deploy-serverless-microservice/","title":"Manually Build And Deploy A Serverless Microservice","tags":[],"description":"","content":"Manually Build And Deploy A Serverless Microservice In this exercise, you will manually create and configure a serverless microservice. As you progress through this lab, you will use other techniques for build and deployment, so that you can compare and contrast the efficiencies of each approach and how automation makes the development experience more agile and increases developer efficiency.\nYou will create the TripSearch microservice manually. The TripSearch microservice exposes the following functions:\n/trips - returns a list of all available trips in the system. /tripsfromcity - returns a list of all trips that originate from a given city /tripstocity - returns a list of all trips that have the given city as a destination This is the same microservice we looked at in a previous lab. But this time, we will expose this functionality in our TravelBuddy website, and so need to deploy the service to be available to the website. Previously, the API Gateway configuration was taken care of for you by the deployment pipeline - in this exercise, you will manually configure the setup of both the Lambda function and the API Gateway.\nDownload source code and build the deployment artefact TripSearchFull Project TripSearchFull.zip (21 KB) Download TripSearchFull.zip file and extract Open Command Prompt and navigate to the directory of the TripSearchFull project was extracted in step 1 Execute the below command: set AWS_PROFILE=devaxacademy set DDB_TABLENAME_TRIPSECTOR=TravelBuddyTripSectors mvn test 3. You will see the following result: Note that the from and to city examples shown here, and the dates and times, will be different for your environment because they have been randomly generated.\nYou should see no errors emitted by the unit test, which confirms the source code is building and running as expected. If you see an error, investigate.\nWhy am I seeing the message AWS X-ray unavailable - ignoring in the output? When you run the tests on your local development environment, the AWS X-ray agent is not available, and so the calls through the AWS SDK cannot be recorded with AWS X-ray. However, since the pom.xml file defines a dependency to the AWS X-ray recorder, all calls through the SDK (for example, to DynamoDB) are attempted to be recorded. This would normally cause an error, and the tests would fail.\nNotice that each of the Lambda handler classes extend a base class called LambdaHandlerWithXRayBase? In this class, there is a static initializer, and it builds ContextMissingStrategy object, overrides the behaviour for when there is no AWS X-ray context, and sets this as the default behaviour. In the implementation of the contextMissing handler, we simply print a message to the console, rather than the default action, which is to throw an exception. The implementation of the LambdaHandlerWithXRayBase class looks like this:\npublic class LambdaHandlerWithXRayBase { static { AWSXRayRecorderBuilder builder = AWSXRayRecorderBuilder.standard(); builder.withContextMissingStrategy(new ContextMissingStrategy() {\t@Override public void contextMissing(String arg0, Class\u0026lt;? extends RuntimeException\u0026gt; arg1) { System.out.println(\u0026#34;AWS X-ray unavailable - ignoring\u0026#34;); }\t}); AWSXRay.setGlobalRecorder(builder.build()); } } As an optional experiment, you could try removing the static initializer from the LambdaHandlerWithXRayBase base class, and re-running the Maven build. You will see errors such as:\ncom.amazonaws.xray.exceptions.SegmentNotFoundException: Thread failed to begin a subsegment: segment not found. Verify that a segment is in progress, and that the SegmentContextResolverChain is configured correctly in order to discover the segment. Without the agent being present, and the call to the Lambda function having the correct correlation Id context passed to it, the SegmentContextResolverChain cannot determine the AWS X-ray segment to attach the recorded metadata to, and throws an exception. The implementation we provide in the base class overrides this behaviour, to safely ignore this condition while testing on your development environment.\nIf the unit test run is succeeding, Execute the command mvn package shade:shade to build It will take a few moments to complete the build. When the target JAR is built, whick is in the folder target of the project and whose name is tripsearch-1.0.0.jar Go to Amazon CloudFormation Console. Click Stacks Type DevAx-06 in the search bar and press Enter Click DevAx-06 Click tab Outputs Save the value LambdaRoleARN and S3BucketLambdaCodeBucketName to use in the next step In Command Prompt, execute the below command aws s3 cp target/tripsearch-1.0.0.jar s3://\u0026lt;S3BucketLambdaCodeBucketName\u0026gt; --region \u0026lt;YOUR_REGION\u0026gt; Replace \u0026lt;S3BucketLambdaCodeBucketName\u0026gt; by the value S3BucketLambdaCodeBucketName we saved in step 7\nReplace \u0026lt;YOUR_REGION\u0026gt; by your Region\n9. Execute the following command to create a new Lambda function from this deployment artefact\naws lambda create-function --function-name idevelopTripSearchFull --runtime java8 --role \u0026lt;LambdaRoleARN\u0026gt; --handler devlounge.lambda.FindAllTripsHandler --code S3Bucket=\u0026lt;S3BucketLambdaCodeBucketName\u0026gt;,S3Key=tripsearch-1.0.0.jar --timeout 15 --description \u0026#34;TravelBuddy TripSearch microservice - FindAllTrips\u0026#34; --memory-size 1024 --region \u0026lt;YOUR_REGION\u0026gt; Replace \u0026lt;LambdaRoleARN\u0026gt; by the value LambdaRoleARN we saved in step 7\nReplace \u0026lt;S3BucketLambdaCodeBucketName\u0026gt; by the value S3BucketLambdaCodeBucketName we saved in step 7\nReplace \u0026lt;YOUR_REGION\u0026gt; by your Region\n10. If successful, your new Lambda function will be created and you will see an output similar to the following: Create two new Lambda functions using the same deployment artefact The code that implements our TripSearch function has three handlers exposed - one for finding all trips; one for finding trips that originate from a given city; and one for finding trips that have a given city as the destination. We have exposed only one handler so far - the search for all trips. In this section, we will create two new Lambda functions, each exposing one of the two remaining handlers.\nCreate a new Lambda function from the same deployment artefact we previously uploaded. We can create different Lambda functions from the same artefact because the artefact exports multiple Lambda handlers. In the step above, we exposed devlounge.lambda.FindAllTripsHandler. In this step we expose devlounge.lambda.FindTripsFromCityHandler. Execute the following command: aws lambda create-function --function-name idevelopTripSearchFromCity --runtime java8 --role \u0026lt;LambdaRoleARN\u0026gt; --handler devlounge.lambda.FindTripsFromCityHandler --code S3Bucket=\u0026lt;S3BucketLambdaCodeBucketName\u0026gt;,S3Key=tripsearch-1.0.0.jar --timeout 15 --description \u0026#34;TravelBuddy TripSearch microservice - FindTripsFromCity\u0026#34; --memory-size 1024 --region \u0026lt;YOUR_REGION\u0026gt; Replace \u0026lt;LambdaRoleARN\u0026gt; by the value LambdaRoleARN we saved in step 7\nReplace \u0026lt;S3BucketLambdaCodeBucketName\u0026gt; by the value S3BucketLambdaCodeBucketName we saved in step 7\nReplace \u0026lt;YOUR_REGION\u0026gt; by your Region\n12. Create the last Lambda function from the same deployment artefact, this time for FindTripsToCity. As per the previous step, we are exposing an additional handler, this time devlounge.lambda.FindTripsToCityHandler. Execute the following command:\naws lambda create-function --function-name idevelopFindTripsToCity --runtime java8 --role \u0026lt;LambdaRoleARN\u0026gt; --handler devlounge.lambda.FindTripsToCityHandler --code S3Bucket=\u0026lt;S3BucketLambdaCodeBucketName\u0026gt;,S3Key=tripsearch-1.0.0.jar --timeout 15 --description \u0026#34;TravelBuddy TripSearch microservice - FindTripsToCity\u0026#34; --memory-size 1024 --region \u0026lt;YOUR_REGION\u0026gt; Replace \u0026lt;LambdaRoleARN\u0026gt; by the value LambdaRoleARN we saved in step 7\nReplace \u0026lt;S3BucketLambdaCodeBucketName\u0026gt; by the value S3BucketLambdaCodeBucketName we saved in step 7\nReplace \u0026lt;YOUR_REGION\u0026gt; by your Region\nConfirm that you receive a success response similar to the response when you successfully created the first Lambda function.\n"},{"uri":"https://hotloncon1.github.io/aws-lab000055/4-configure-aaa/4.2-setup-authentication/","title":"Microservice Authentication","tags":[],"description":"","content":"Setting Up Authentication For The Microservice Right now, if you click the Go! button on the web site and do not enter a city to filter, you will see a dialog with all available trips. We want to change this behaviour so that you must be logged in in order to be able to search for all trips without a filter. This is just an example to demonstrate how we could limit certain API calls to only authenticated users.\nGo to AWS API Gateway Console. Type iDevelop - Trip Search API to the search bar Click iDevelop - Trip Search API Click Gateway Responses Select Unauthorized Click Edit In order for our web application to be able to receive the unauthorized 401 status, we need to add CORS headers to the response. Without the headers, the browser will not have permission to receive the 401 status. We have already enabled CORS for status 200 responses when we set up the API Gateway endpoints earlier. But we need to explicitly allow for status 401 to be returned. Click Add response header In the Response header column of the first Response Header, type Access-Control-Allow-Origin In the Value column, type '*' In the Response header column of the second Response Header, type Access-Control-Allow-Headers In the Value column, type '*' Click Save Create an Authorizer that uses the Cognito User Pool API Gateway integrates tightly with Cognito for authorization. You simply need to declare your Cognito User Pool as an authorizer for your API.\nClick Authorizers Click Create New Authorizer In the Name section, type TravelBuddy In the Type section, select Cognito In the Cognito User Pool section, select TravelBuddy In the Token Source section, type Authorization Click Create Mark the /trips microservices to require authentication Click Resources Click the GET method beneath /trips Click Method Request In the Authorization section, click the pencil icon Select TravelBuddy. This is the authoriser we created in the previous step, and links to the Cognito User Pool we are using for our user database. If it does not appear, try refreshing your browser. Click the grey tick next to the field to save the change. "},{"uri":"https://hotloncon1.github.io/aws-lab000055/2-prepare/","title":"Preparation","tags":[],"description":"","content":"Overview In this section, we will create the Key Pair, create the CloudFormation stack and Connect to the Windows instance.\nContent: Create the Key Pair Create the CloudFormation stack Connect to the Windows instance "},{"uri":"https://hotloncon1.github.io/aws-lab000055/2-prepare/2.3-connectvirtualmachine/","title":"Connect to the Windows Instance","tags":[],"description":"","content":"Connect to the Windows Instance Go to Amazon EC2 console. On the left navigation bar, click Intances. Select DevAxWindowsHost. Click Connect. In the Connect to instance page Click tab RDP client. Click Download remote desktop file. We will download file remote desktop to the folder contains the key pair. Click Get password. In the Get Windows password page: Click Browse. Select file KPforDevAxInstances.pem we downloaded in the section 1.1. Click Decrypt Password to decrypt the password. Copy decrypted password . Open file DevAxWindowsHost.rdp we downloaded in step 2. Click Connect. Type the password we copied in step 4 Click OK. Click Don’t ask me again for connections to this computer. Click Yes. Connect successfully. Cấu hình AWS CLI Assign the Administrator Access to user awsstudent was created by Cloud Formation template Go to AWS IAM Console. Click Users. Click user awsstudent In the Permissions policies section Click Add permissions In the Add permissions to awsstudent page Click Attach existing policies directly Type AdministratorAccess to the search bar. Select AdministratorAccess Click Next:Review Click Add Permission Click tab Security credentials Click Create access key to create the access key Save Access key and Secret access key to use in the next steps Execute the below command: aws configure set profile.devaxacademy.region \u0026lt;your_region\u0026gt; aws configure set profile.devaxacademy.aws_access_key_id \u0026lt;access_key_id\u0026gt; aws configure set profile.devaxacademy.aws_secret_access_key \u0026lt;secret_access_key\u0026gt; git config --global user.email \u0026lt;YOUR_EMAIL\u0026gt; git config --global user.name awsstudent Change \u0026lt;your_region\u0026gt; by Region code Change \u0026lt;access_key_id\u0026gt; by Access Key Id we saved in step 6\nChange \u0026lt;secret_access_key\u0026gt; by Secret Access Key we saved in step 6\n"},{"uri":"https://hotloncon1.github.io/aws-lab000055/3-create-single-page-app/3.3-create-api-with-api-gateway/","title":"Create And Expose the API with Amazon API Gateway","tags":[],"description":"","content":"Create And Expose the API with Amazon API Gateway Go to AWS API Gateway console. In the Choose an API type section, find REST API - Develop a REST API where you gain complete control over the request and response along with API management capabilities. Click Build Click OK In the Create new API section, select New API In the API name section, type iDevelop - Trip Search API In the Description section, type Allows searching ở trips from/to cities Click Create API The API will be created, and have a root path element and nothing else. Click Actions Click Create Resource In the New Child Resource page In the Resource Path section, type trips Check Enable API Gateway CORS Click Create Resource The /trips resource will be created. Click on the /trips link Click Actions Click Create Method In the dropdown list that appears, select GET Click the grey tick next to the dropdown list to commit the change. In the Lambda Region section, select your Region In the Lambda Function section, type idevelop and select idevelopTripSearchFull Click Save Click OK When the method is created, you will see the Method Execution panel: Click Test Click Test After a moment or two for the Lambda function to initialise and execute, you should see an output similar to this: Click /trips Click Actions Click Enable CORS Click Enable CORS and replace existing CORS headers Click Yes, replace existing values When each of the listed items have a green tick against them, you can move on to the next section. This will only take a moment. Expose the /tripsfromcity RESTful API endpoint The first path we exposed was quite simple - /trips gets all the trips in the system. But we know our source code implementation allows us to specify a filter to query for trips that originate from a particular city or have a particular destination, so we want to expose this functionality to our API consumers. First, we will expose the /tripsfromcity path.\nIn the Resources section, click / Click Actions Click Create Resource In the Resource Name section, type tripsfromcity Select Enable API Gateway CORS Click Create Resource Our call into the Lambda function requires a city parameter. We will follow the standard pattern for RESTful interfaces, and pass this parameter in as a URL parameter. Select /tripsfromcity Click Actions Click Create Resource In the Resource Name section, type {city} In the Resource Path section, delete the default and replace with {city} Click Create Resource Click /{city} Click Actions Click Create Method In the dropdown list that appears, select GET Click the grey tick next to the dropdown list to commit the change. In the Lambda Region section, select your Region In the Lambda Function section, type idevelop and select idevelopTripSearchFromCity Click Save Click OK When the method is created, you will see the Method Execution panel. as before for the /trips resource. We can’t go ahead and test the API call just yet, because we need to transform the request through API Gateway so that the city parameter is passed through to the Lambda function correctly. The devlounge.lambda.FindTripsFromCityHandler handler expects to see the input data in this JSON format:\n{ \u0026#34;payload\u0026#34; : { \u0026#34;city\u0026#34;: \u0026#34;Melbourne\u0026#34; } } This would cause the Lambda function to search DynamoDB for all trips that originate from Melbourne. We need to add a Body Mapping Template for this method in API Gateway to correctly transform the request into this format.\nClick Integration Request Click Mapping Templates Click When there are no templates defined (recommended) Click Add mapping template In the Content-Type section , type application/json Click the grey tick icon to commit the change. Scroll further down to show the mapping template entry text field. Paste in the following template: { \u0026#34;payload\u0026#34; : { \u0026#34;city\u0026#34;: \u0026#34;$input.params(\u0026#39;city\u0026#39;)\u0026#34; } } This template will take the parameter {city} from the URL and add it into a JSON payload that is sent to the Lambda function, as a property of the payload object, just as the Lambda function expects.\nClick Save The schema defined here for this Lambda function is completely arbitrary, and in your own application you could use a completely different model. The mapping template gives you the flexibility to transform the inbound data on-the-fly through the API Gateway endpoint.\nClick Method Execution Click Test In the Path section, in {city} field, type Melbourne Click Test API Gateway will make the call into the Lambda function, passing the value Melbourne into the Body Mapping Template you have defined, which will insert the search parameter Melbourne into the JSON payload that is sent to the Lambda function. This will cause the function handler to consume the JSON and execute a search in the DynamoDB table, and return the results. You will see a result similar to this: Select /{city} in /tripsfromcity section Click Actions Click Enable CORS Click Enable CORS and replace existing CORS headers Click Yes, replace existing values When each of the listed items have a green tick against them, you can move on to the next section. This will only take a moment. Click / in Resources section Click Actions Click Create Resource In the Resource Name section, type tripstocity Select Enable API Gateway CORS Click Create Resource Our call into the Lambda function requires a city parameter. We will follow the standard pattern for RESTful interfaces, and pass this parameter in as a URL parameter. Click /tripstocity Click Actions Click Create Resource In the Resource Name section, type {city} In the Resource Path section, delete the default and replace with {city} Select Enable API Gateway CORS Click Create Resource Click /{city} in the section /tripstocity Click Actions Click Create Method In the dropdown list that appears, select GET Click the grey tick next to the dropdown list to commit the change. In the Lambda Region section, select your Region In the Lambda Function section, type idevelop and select idevelopTripSearchToCity Click Save Click OK When the method is created, you will see the Method Execution panel, as before for the /tripsfromcity resource. We again need to transform the request through API Gateway so that the city parameter is passed through to the Lambda function correctly, before we can test this API call. The devlounge.lambda.FindTripsToCityHandler handler expects to see the input data in this JSON format:\n{ \u0026#34;payload\u0026#34; : { \u0026#34;city\u0026#34;: \u0026#34;Melbourne\u0026#34; } } This would cause the Lambda function to search DynamoDB for all trips that have Melbourne as a destination. We need to add a Mapping Template for this method in API Gateway to correctly transform the request into this format.\nClick Integration Request Click Mapping Templates Select When there are no templates defined (recommended) Click Add mapping template In the Content-Type section, type application/json Click the grey tick to commit the change Scroll further down to show the mapping template entry text field. Paste in the following template: { \u0026#34;payload\u0026#34; : { \u0026#34;city\u0026#34;: \u0026#34;$input.params(\u0026#39;city\u0026#39;)\u0026#34; } } Click Save Click Method Execution Click Test In the Path section, in the {city} field, type Melbourne Click Test API Gateway will make the call into the Lambda function, passing the value Melbourne into the Body Mapping Template you have defined, which will insert the search parameter Melbourne into the JSON payload that is sent to the Lambda function. This will cause the function handler to consume the JSON and execute a search in the DynamoDB table, and return the results. You will see a result similar to this: Click /{city} in /tripstocity section Click Actions Click Enable CORS Click Enable CORS and replace existing CORS headers Click Yes, replace existing values When each of the listed items have a green tick against them, you can move on to the next section. This will only take a moment. If you have completed the steps above as described, you will have a resources tree that looks like this: Deploy the API and test Now that you have confirmed that the microservices are functioning correctly, you are ready to deploy the API and test it from the publicly available endpoint. In the Resources section, click / Click Actions Click Deploy API In the Deployment stage section, select [New Stage] to create a new deployment stage. In the Stage name section, type prod In the Stage description section, type Trips API In the Deployment description section, type Initial deployment Click Deploy The new stage prod will be created and you will see the prod Stage Editor Click Invoke URL A new window will open and hit the stage endpoint. You will see an error message stating {\u0026ldquo;message\u0026rdquo;:\u0026ldquo;Missing Authentication Token\u0026rdquo;}. This is because there is no handler for the root of the stage - you have only defined resources/methods beneath the /trips, /tripsfromcity and /tripstocitypaths. Edit the URL in the URL bar of the browser and append /trips then press Enter. The page will refresh, and then display all of the available trips as JSON. The output will be similar to this: Test the /tripsfromcity method, use /tripsfromcity/Melbourne to search for all trips that leave from Melbourne. Test the /tripstocity method, use /tripstocity/Melbourne to search for all trips that go to Melbourne. NIf the data looks right, and there are no errors, you are ready to move on to the next exercise.\nUse CloudFormation/SAM via the AWS CLI to deploy the HotelSearch microservice In the previous steps, you manually deployed and configured the TripSearch microservice, including the Lambda functions and API Gateway resources. You will have noticed that there are quite a few steps required, and doing this manually is time consuming and prone to errors. In this step, you will use the AWS CLI and CloudFormation/SAM to deploy the HotelSearch microservice, instead of manually deploying the resources.\nBy using CloudFormation/SAM, many of the manual steps will be taken care of for you, streamlining the deployment process. You will still have to manually trigger the process, but the actual deployment will be automated.\nThe HotelSpecials microservice needs to access a MySQL database to retrieve the hotel specials data. The lab environment has automatically deployed and seeded a database for you, and the connection details are provided in Cloudformation Outputs tab with instructions below on where to update the placeholder in the template you will use to deploy the microservice. The MySQL instance has been deployed using Amazon RDS and is not publicly-accessible since it is launched in a private subnet. Therefore, for the Lambda function to be able to connect to the database, the Lambda function will also need to be deployed into a private subnet by enabling VPC Integration. The template.yml file provided has all the required setup to do this, you just need to update the placeholders as per the below instructions.\nHotelSpecials Project HotelSpecials.zip (10 KB) Download the HotelSpecials.zip file and extract Open Command Prompt and navigate to the directory of the HotelSpecials project was extracted in step 65 Execute the following command: set AWS_PROFILE=devaxacademy mvn package shade:shade 67. When the target JAR is built, whick is in the target folder of the project and whose name is hotelspecials-1.0.0.jar 68. Go to AWS CloudFormation Console.\nClick Stack. Type DevAx-06 to the search bar and press Enter. Click DevAx-06. Click tab Output Save the value of DatabaseSecurityGroup, DatabaseSubnet1, DatabaseSubnet2, RDSEndpoint and S3BucketLambdaCodeBucketName to use in the next step. In the Eclipse IDE, open the template.yml file Replace \u0026lt;DatabaseSecurityGroup\u0026gt; by the DatabaseSecurityGroup value we saved in step 69 Replace \u0026lt;DatabaseSubnet1\u0026gt; by the DatabaseSubnet1 value we saved in step 69 Replace \u0026lt;DatabaseSubnet2\u0026gt; by the DatabaseSubnet2 value we saved in step 69 Replace \u0026lt;RDSEndpoint\u0026gt; by the RDSEndpoint value we saved in step 69 In the Command Prompt, execute the following command to package the Lambda function aws cloudformation package --template template.yml --s3-bucket \u0026lt;S3BucketLambdaCodeBucketName\u0026gt; --output-template template-export.yml Replace \u0026lt;S3BucketLambdaCodeBucketName\u0026gt; by the S3BucketLambdaCodeBucketName value we saved in step 69\nThe command will upload the build artefact to the S3 bucket, and then update the template.yml pointer to the code artefact on S3, and write out a new template with this update included, to a file called template-export.yml\nIt will take a moment or two for the upload of the artefact to complete.\n73. Execute the following command to create and deploy a CloudFormation Change Set\naws cloudformation deploy --template-file template-export.yml --stack-name HotelSpecialsAPI --capabilities CAPABILITY_IAM 74. Go to AWS CloudFormation Console.\nClick Stack. You will see the HotelSpecialsAPI stack. This indicates that the CloudFormation Change Set has been created. The command you issued will create the Change Set and then automatically execute the Change Set. It will take a few moments to complete the execution Select HotelSpecialsAPI stack, click tab Events and eview the steps that the CloudFormation template has applied to your environment. These will match the resources and actions in the template-output.yml file. Go to AWS API Gateway console Click iDevelop - Hotel Specials API Click Get Click Integration Request The Integration Request panel will be shown. Lambda Function specified: The specified value is not a Lambda function, but instead, is a Stage Variable that will be replaced at runtime by API Gateway. Therefore, in order for this API call to succeed, the Stage in API Gateway must have defined a value for the envHotelSpecials stage variable.\nClick Stages Click prod Click tab Stage Variables a single variable is defined - envHotelSpecials - which correlates to the stage variable name the GET method was expecting. The value of the variable is GetHotelSpecials which is the name of the Lambda function that the template created using the JAR file you built and uploaded during the package/deploy process.\nTest the HotelSpecials API Expand the prod root element in the Stages list to reveal the hierarchy. Click Get Click Invoke URL After a moment while the Lambda function is initialised, you should see the JSON result of querying the mySQL database from the Lambda function If you see a JSON payload with no errors, you have successfully deployed an API and supporting Lambda function that queries the mySQL database. Notice how much quicker and easier that was to deploy without any manual intervention? That is the power of automation. In the next exercise, we will take this one step further, using the (now familiar) CI/CD pipeline approach to deploy our next API.\n"},{"uri":"https://hotloncon1.github.io/aws-lab000055/3-create-single-page-app/","title":"Creating A Single Page Application","tags":[],"description":"","content":"Overview In this exercise you will create the Single Page Application (SPA) website for TravelBuddy. A single-page application is a web application or website that interacts with the user by dynamically rewriting the current web page with new data from the web server, instead of the default method of the browser loading entire new pages. The SPA will interact with a set of APIs exposed by API Gateway.\nContent: Create A DynamoDB Table Manually Build And Deploy A Serverless Microservice Create And Expose the API with Amazon API Gateway Deploy the api using code star and CI/CD Setup The Single Page Application Website Build A Client To Consume The API "},{"uri":"https://hotloncon1.github.io/aws-lab000055/4-configure-aaa/4.3-deploy-and-test/","title":"Deploy And Test","tags":[],"description":"","content":"Deploy And Test The New Behaviour Click Actions Click Deploy API In the Deployment stage section, select prod Click Deploy Switch over to your TravelBuddy SPA web page and refresh it. Without entering a destination value, click the Go! button. After a moment, you should see a toaster element appear stating that you must be logged-in in order to use the feature. "},{"uri":"https://hotloncon1.github.io/aws-lab000055/4-configure-aaa/4.4-add-new-user-signup_signin/","title":"Add New User Sign Up and Sign In","tags":[],"description":"","content":"Add New User Sign Up and Sign In Go to Amazon Cognito Console. Click Federated Identities Click TravelBuddy Click Edit identity pool Here we can set up Unauthenticated roles (roles which are assumed when a user is not signed in), and Authenticated roles (roles which are assumed when a user is signed in). Verify that the Unauthenticated role is set to the role that contains the string CognitoIAMUnauthenticatedRole. This was created during lab setup. Verify that the Authenticated role is set to the role that contains the string CognitoIAMAuthenticatedRole. This was created during lab setup. You now have everything in place to register and sign-in as a user, and then test the signed-in behaviour of the /trips microservice now that it is protected by requiring authorization.\nIn the TravelBuddy page, click Login or Register Click Sign-up here! In the First Name section, type your first name In the Last Name section, type your last name In the Email Address section, type your email You must provide a valid email address and one that you have access to immediately, in order to retrieve the verification code you will be sent.\nIn the Password section, type your password Click Register Check your email, save the verification code In the Verification Code section, type the verification code we saved in step 8 Click Verify Sign-in using the credentials (email address and password) you provided during registration. You will now be signed in and the banner will change to show My Account Click My Account, we will see the only feature that is implemented is the Logout option. Click Go! without any text entered. We are shown the full trips list in a dialog Sign out and click Go! without any text entered. We will see the error message again. "},{"uri":"https://hotloncon1.github.io/aws-lab000055/4-configure-aaa/","title":"Configure Authentication, Authorization and Accounting (AAA)","tags":[],"description":"","content":"Overview In this section, we will follow the same process we followed in the previous Labs to provision a CI/CD pipeline to manage the automated deployment of our new Trip Search microservice.\nContent: Add Authentication to the SPA using Amazon Cognito User Pools Setting Up Authentication For The Microservice Deploy And Test Add New User Sign Up and Sign In "},{"uri":"https://hotloncon1.github.io/aws-lab000055/3-create-single-page-app/3.4-deploy-api-with-codestar/","title":"Deploy the api using code star and CI/CD","tags":[],"description":"","content":"Create a CI/CD pipeline with AWS CodeStar cd C:\\Users\\Administrator\\git\\FlightSpecialsAPI git checkout -b \u0026#34;new-implementation\u0026#34; cd C:\\Users\\Administrator\\Downloads\\FlightSpecials copy_files.sh C:\\Users\\Administrator\\git\\FlightSpecialsAPI git checkout \u0026ldquo;new-implementation\u0026rdquo;\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.3.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-autoconfigure\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.3.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.json\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;json\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;20180130\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.amazonaws.serverless\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aws-serverless-java-container-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.junit.jupiter\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-jupiter-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Go to AWS CodeStar Console. Click Projects Click Create project Click Create service role if you never go to AWS CodeStar Service before.\nIn the Templates page, select Java and AWS Lambda Select Java Spring Click Next In the Project name section, type FlightSpecialsAPI Click Next In the Review page, click Create project Add awsstudent account to the the team with Owner role. Click Team Click Add team member In the Team member details section In the User section, select awsstudent In the Email address section, type your email In the Project role section, select Owner CLick Allow SSH access to project instances. Click Add team member Check added team member Go to AWS CloudFormation Console. Click Stack. Type DevAx-06 to the search bar and click Enter. Click DevAx-06. Click tab Output Save GitPassword value and GitUserName value to use in the next step. Open Eclipse IDE. Find the AWS Icon and click it to reveal the menu Click Import AWS CodeStar Project… Select your region Select FlightSpecialsAPI Type the saved information in step 9 to User name section and Password section Click Next Click OK, ignore the error org.eclipse.egit.ui.internal.repository.tree.RepositoryTreeNodeType.getIcon()Lorg/eclipse/swt/graphics/Image; Select master branch and click Next. Click Finish. Click No to skip setup password hint. Project sample was created by CodeStar was imported Open Command Prompt, execute the below command to go to the directory where the IDE code is located and to create and switch to the new branch cd C:\\Users\\Administrator\\git\\FlightSpecialsAPI git checkout -b \u0026#34;new-implementation\u0026#34; FlightSpecials Project FlightSpecials.zip (15 KB) Download the FlightSpecials.zip file and extract. In the Command Prompt, navigate to the directory of the FlightSpecials folder we extracted in step 17 Execute the following command to overwrite the implementation provided by CodeStar with the contents of the FlightSpecials.zip file we extracted in step 17. We have provided a copy_files.sh script in the FlightSpecials.zip bundle that you can use copy_files.sh C:\\Users\\Administrator\\git\\FlightSpecialsAPI 19. In the Eclipse IDE, right-click on the FlightSpecialsAPI project we imported\nClick Maven Click Update Project\u0026hellip; Give CloudFormation permission to create an IAM role Go to AWS IAM Console. Click Roles. Type CodeStarWorker-flightspecialsa-CloudFormation to the search bar and press Enter Click CodeStarWorker-flightspecialsa-CloudFormation. If you can’t find the role, it may be too early - CodeStar may still be provisioning the pipeline and may not yet have created the role. Check the progress of the provisioning in the CodeStar dashboard.\nClick Add permissions Click Attach Policies Type idevelop to the search bar and press Enter Select idevelopCodeStarCloudFormationPolicy Click Attach Policies Update placeholder parameters in the CloudFormation template Trong Eclipse IDE, open the template.yml file Do the same step 68 and step 69 in the 3.3 section to get the DatabaseSecurityGroup value, the DatabaseSubnet1 value, the DatabaseSubnet2 value and the RDSEndpoint value Replace \u0026lt;DatabaseSecurityGroup\u0026gt; with the DatabaseSecurityGroup value Replace \u0026lt;DatabaseSubnet1\u0026gt; with the DatabaseSubnet1 value Replace \u0026lt;DatabaseSubnet2\u0026gt; with the DatabaseSubnet2 value Replace \u0026lt;RDSEndpoint\u0026gt; with the RDSEndpoint value Save Update the target AWS region in the swagger.yml API definition file The swagger.yml file provided in the zip bundle is the definition for the API that exposes the microservice via Amazon API Gateway. It needs to be updated with details of your lab AWS Account Id and target AWS Region before you can deploy your microservice.\nIn the Eclipse IDE, open the swagger.yml file Press Ctrl+F shortcut In the Find section, type REPLACE_AWS_REGION In the Replace with section, type your Region Click Replace All to replace In the Find section, type REPLACE_AWS_ACCOUNTID In the Replace with section, type your AWS Account Id Click Replace All to replace Save Now that you have completed updating files, you need to add the changed files to your new-implementation git branch and commit the files. Open Command Prompt, execute the below command to navigate to the directory of the FlightSpecialsAPI folder and review the changed code files cd C:\\Users\\Administrator\\git\\FlightSpecialsAPI git status 27. Execute the below command to add in the changed files\ngit add . git commit -m \u0026#34;Baseline implementation\u0026#34; 28. Execute the below command to switch back to the master branch\ngit checkout master 29. Execute the below command to merge the changes for your new-implementation branch into the master branch\ngit merge new-implementation 30. In the Eclipse IDE, right-click on the FlightSpecialsAPI project\nClick Team Click Push to origin. Click Close You need to perform the push from Eclipse because the git credentials are embedded within the Eclipse environment. You could also configure the command line environment with the git credentials but that is beyond the scope of this lab.\nIt will take a few moments to push the code and commence the deployment. Checking in the source code and templates will trigger the pipeline to build and deploy the new implementation. AWS CodePipeline will now use CloudFormation to deploy the following resources:\nThe Lambda function implemented by the Java code you checked into CodeCommit IAM role for the Lambda function API Gateway configuration for the API While you have some time, spend a few minutes to explore the buildspec.yml, swagger.yml and template.yml files which define the Amazon API Gateway, AWS Lambda function and the build/deployment process through AWS CodeBuild. You will notice that the builspec.yml file uses the same AWS CLI command to package the deployment that you used when you manually packaged the HotelSpecials API earlier.\nDo not execute these commands below, they are here as a reference!\nmvn package shade:shade aws cloudformation package --template template.yml --s3-bucket $S3_BUCKET --output-template template-export.yml The template.yml file uses the Serverless Application Model (SAM) transform to define the REST API, as opposed to how we approached this in the HotelSpecials API example. In HotelSpecials, the CloudFormation template used canonical CloudFormation to define the REST API so that it could be explicit about the API definition and include the swagger definition inline. The FlightSpecials example uses a more declarative approach and left the details to SAM. You are free to mix CloudFormation and SAM in the same template, as you can see from these examples.\nTest the FlightSpecials API Go to AWS API Gateway console Type iDevelop - Flight Specials API to the search bar and press Enter Click iDevelop - Flight Specials API Click Stages Expand the prod root element Click GET Click Invoke URL After a moment while the Lambda function is initialised, you should see the JSON result of querying the mySQL database from the Lambda function If you see a JSON payload with no errors, you have successfully deployed an API and supporting Lambda function that queries the mySQL database. Notice how much quicker and easier that was to deploy without any manual intervention, and you didn’t even have to interact with the AWS CLI or Console? Everything was driven by the source control check-in process.\nYou are now ready to integrate these APIs with the TravelBuddy web site.\n"},{"uri":"https://hotloncon1.github.io/aws-lab000055/3-create-single-page-app/3.5-setup-single-page-app-website/","title":"Setup The Single Page Application Website","tags":[],"description":"","content":"Setup The Single Page Application Website Now that we have our three APIs set up, we are ready to call them from a web page. First, we need to set up our single-page web application (SPA) and host it on Amazon S3.\nWe have decided to use the AngularJS framework for our SPA. You could of course use any suitable framework. The aim of this Lab is not to teach you AngularJS or any other SPA framework, so we won’t be diving into the details of how the page works, other than to guide you through wiring up the API calls that the SPA will need to make to populate its data elements.\nSPA Project www.zip (5660 KB) Download the www.zip file and extract Generate client SDKs for each of the three APIs and deploy to the SPA The SPA implementation you have been provided has stubbed-out implementations of the three APIs we want to expose to our users. They have just enough implementation to not cause an error on the page when executed, but they do not provide any data. In order to ‘wire up’ our APIs to the SPA, we will need to generate the Javascript client SDKs that relate to these APIs and store them in the appropriate path.\nGo to AWS API Gateway console Type iDevelop - Flight Specials API to the search bar and press Enter Click iDevelop - Flight Specials API Click Stages Select prod Click tab SDK Generation In the Platform section, select Javascript Click Generate SDK. The Javascript SDK for the API will be downloaded by your browser. Extract the file we downloaded in step 3 Find the apigClient.js file inside the folder we extracted and rename this file as apigClient_FlightSpecials.js Open the apigClient_FlightSpecials.js file in the Eclipse IDE. Use Search/Replace and replace apigClientFactory with apigClientFactory_FlightSpecials. There will be 2 occurrences to replace, both at the start of the file. Press Ctrl+F shortcut In the Find section, type apigClientFactory In the Replace with section, type apigClientFactory_FlightSpecials Click Replace All to replace Save Copy the apigClient_FlightSpecials.js file to the api folder inside the www folder inside the working folder for the SPA on your local development environment. Replace the apigClient_FlightSpecials.js file inside the api folder For iDevelop - Hotel Specials API, do the same iDevelop - Flight Specials API Go to AWS API Gateway console Type iDevelop - Hotel Specials API to the search bar and press Enter Click iDevelop - Hotel Specials API Click Stages Select prod Click tab SDK Generation In the Platform section, select Javascript Click Generate SDK. The Javascript SDK for the API will be downloaded by your browser. Extract the file we downloaded in step 8 Find the apigClient.js file inside the folder we extracted and rename this file as apigClient_HotelSpecials.js Open the apigClient_HotelSpecials.js file in the Eclipse IDE. Use Search/Replace and replace apigClientFactory with apigClientFactory_HotelSpecials. Press Ctrl+F shortcut In the Find section, type apigClientFactory In the Replace with section, type apigClientFactory_HotelSpecials Click Replace All to replace Save Copy the apigClient_HotelSpecials.js file to the api folder inside the www folder inside the working folder for the SPA on your local development environment. Replace the apigClient_HotelSpecials.js file inside the api folder For iDevelop - Trip Search API, do the same iDevelop - Flight Specials API Go to AWS API Gateway console Type iDevelop - Trip Search API to the search bar and press Enter Click iDevelop - Trip Search API Click Stages Select prod Click tab SDK Generation In the Platform section, select Javascript Click Generate SDK. The Javascript SDK for the API will be downloaded by your browser. Extract the file we downloaded in step 13 Find the apigClient.js file inside the folder we extracted and rename this file as apigClient_TripSearch.js Open the apigClient_TripSearch.js file in the Eclipse IDE. Use Search/Replace and replace apigClientFactory with apigClientFactory_TripSearch. Press Ctrl+F shortcut In the Find section, type apigClientFactory In the Replace with section, type apigClientFactory_TripSearch Click Replace All to replace Save Copy the apigClient_TripSearch.js file to the api folder inside the www folder inside the working folder for the SPA on your local development environment. Replace the apigClient_TripSearch.js file inside the api folder Push SPA files to Amazon S3 With the API SDKs in place, you are now ready to deploy the SPA code to the Amazon S3 Bucket that will serve the website. The lab setup process has provisioned a suitable S3 bucket, with WebSite Hosting enabled. So you will only need to push all the files from your local machine to the S3 bucket to be able to test the application.\nOpen Command Prompt , navigate to the directory of the www file we extracted in step 1 Execute the following command to synchronize between your local machine and the S3 bucket set AWS_PROFILE=devaxacademy aws s3 sync . s3://\u0026lt;S3BucketWWWBucketName\u0026gt; --acl public-read Replace \u0026lt;S3BucketWWWBucketName\u0026gt; with the S3BucketWWWBucketName value in the Output tab of the DevAx-06 stack\n18. When the synchronize has completed, you are ready to test your SPA hosted on S3. Open the following URL in the web browser\nhttp://\u0026lt;S3BucketWWWBucketName\u0026gt;.s3-website-\u0026lt;YOUR_REGION\u0026gt;.amazonaws.com Repalce \u0026lt;S3BucketWWWBucketName\u0026gt; with the S3BucketWWWBucketName value in the Output tab of the DevAx-06 stack\nRepalce \u0026lt;YOUR_REGION\u0026gt; with your Region\nThe familiar TravelBuddy website should render in your browser. Previously you have seen this website when it was served from a monolithic Java application served off EC2 managed by Elastic Beanstalk. But now, the site is a single-page web application, and is hosted from an S3 bucket, making API calls to Amazon API Gateway to provide data to the website.\nYou should see the Hotel Specials and Flight Specials listings rendered on the page.\nIn addition, a Find trips to… option is available. To test this, enter Melbourne in the text field and click the Go! button. A dialog will appear showing the results of the search. This data is being served from a call to the TripSearchAPI call, for /tripsfromcity.\nIf you clear the value in the field and click the Go! button, you will see a list of all available trips, which is served from the TripSearchAPI call for /trips.\nIf you are not seeing the data as a result of the API calls, take a look at the developer console in the browser, to see if there are any errors that will help track down the issue.\n"},{"uri":"https://hotloncon1.github.io/aws-lab000055/5-tracing-application-performance-with-xray/","title":"Tracing Application Performance With AWS X-Ray","tags":[],"description":"","content":"Tracing Application Performance With AWS X-Ray The TripSearch, HotelSpecials and FlightSpecials Lambda functions each contain the necessary dependencies to support emitting tracing events to AWS X-ray, to allow you to easily trace the calls between the components of your distributed system. In this exercise, you will enable the feature and review the AWS X-ray console.\nGo to AWS Lambda console. Click Functions. Type idevelopTripSearchFull to the search bar and press Enter. Click idevelopTripSearchFull. Click Configuration Click Monitoring and operations tools Click Edit In the AWS X-Ray section, enable the Active tracing Click Save Go to the TravelBuddy SPA page. Sign in to the application if you are not already signed in. Click Go! button without any text entered, to invoke the idevelopTripSearchFull Lambda function. It will take a moment to complete. the dialog is shown displaying the trips. Go to AWS CloudWatch Console. Open X-Ray traces. Click Service map Open Legend and options Click Metrics Click Service map, you will see Service map. Go to AWS Lambda console. Click Functions. Type idevelopTripSearchFull to the search bar and press Enter. Click idevelopTripSearchFull. Click Monitor Click Traces You can now also see the service map directly from Lambda console. Back to the AWS CloudWatch Console. Click Service map Click Client Click View traces In the In the Traces list, click the ID of the the first item You will be able to see a timeline view of the various actions and their execution durations Here, you can see that the overall call took 5,98s, 1.67s of which was taken by the scan of the TravelBuddyTripSectors DynamoDB table.\nEnable active tracing on the other Lambda functions that have been created as part of this lab: idevelopTripSearchFull, idevelopTripSearchFromCity, idevelopTripSearchToCity and GetHotelSpecials. You can do this manually using the console. However, note that the function created through automation with a name starting with awscodestar will have its configuration overwritten if you re-deploy the code\n"},{"uri":"https://hotloncon1.github.io/aws-lab000055/3-create-single-page-app/3.6-build-api-consumer/","title":"Build A Client To Consume The API","tags":[],"description":"","content":"Build A Client To Consume The API You now have a working model of the web site running as an SPA calling for data via RESTful APIs hosted on AWS Lambda, and served from Amazon API Gateway. These data feeds are considered public because the user does not need to be signed-in and provide credentials for the call to the API. In this exercise, we will take a look at how we can require authentication to make the API calls, and the use of API Keys to enforce call-rate throttling and quota management. To demonstrate, we will use a Java client application, to show how you can consume the auto-generated Java SDKs in your applications.\nCreate Response Model for the TripSearch API In order for the SDK generator to create the appropriate classes for a strongly-typed language like Java (as opposed to Javascript, for example) we need to tell API Gateway what the shape or schema of the request/response objects looks like. In the TripSearch API, we are using the GET method for each of the three API calls. Therefore, there is no schema for inbound requests because the city parameter is passed on as part of the URL. If we instead changed the method to POST, we would need to pass in the city parameter in the body payload, and would need to create a model for this object schema for the code generator to create a Java class for us to bind to.\nThe result data from the API calls is returned in the body of the response. In order for the code generator to create an appropriate class to represent this response, we need to create a response model, and set it as the method response model.\nGo to AWS API Gateway console Type iDevelop - Trip Search API to the search bar and press Enter Click iDevelop - Trip Search API Click Models Click Create In the Model name section, type TripsFromCityResponse In the Content-type section, type application/json In the Model schema section, type { \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;succeeded\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;boolean\u0026#34; }, \u0026#34;errorMessage\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;errorType\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; }, \u0026#34;data\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;items\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;date\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; }, \u0026#34;originCity\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;destinationCity\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;airline\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } } } } }, \u0026#34;title\u0026#34;: \u0026#34;TripsFromCityResponse\u0026#34; } Click Create model Assign the TripsFromCityResponse model to the /tripsfromcity API call Click Resources Click the GET method beneath /tripsfromcity/{city} Click Method Response In the /tripsfromcity/{city} - GET - Method Response panel, click the arrow next to HTTP Status to reveal the panel Under Response Body for 200 click the pencil icon next to the Empty model. The field becomes a drop-down list. Select TripsFromCityResponse Click the grey tick to commit the change Click Actions Click Deploy API In the Deployment stage section, select prod Click Deploy On the prod Stage Editor that appears, click SDK Generation In the Platform section, select Java SDK In the Service name section, type TripSearch In the Java package name section, type idevelop.api.sdk Click Generate SDK. The Java SDK will be generated and downloaded as a ZIP file. Extract the downloaded ZIP file we downloaded in step 8 Open Command Prompt and navigate to the directory of the downloaded SDK has been exploded (the directory is called generated-code) Execute the following command mvn install This will compile and install the SDK in your local Maven repository and we will refer to it in the next steps.\nBuild a Java client application that consumes the API TripSearchJavaClient Project TripSearchJavaClient.zip (8 KB) Download the TripSearchJavaClient.zip file and extract In the Eclipse IDE, open the project we extracted in step 10 Open the pom.xml file Replace the pom.xml file contents with the following: \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;idevelop.api.tripsearch.sdk.app\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;TripSearch-sdkClient\u0026lt;/artifactId\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;TripSearch-sdkClient\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.apache.org\u0026lt;/url\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;1.8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;1.8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.8.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;idevelop.api.sdk\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;TripSearch\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;compile\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-shade-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.4\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;shade\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;transformers\u0026gt; \u0026lt;transformer implementation=\u0026#34;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\u0026#34;\u0026gt; \u0026lt;mainClass\u0026gt;idevelop.api.tripsearch.sdk.app.App\u0026lt;/mainClass\u0026gt; \u0026lt;/transformer\u0026gt; \u0026lt;/transformers\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 12. In the Command Prompt, navigate to the directory of the project we extracted in step 10\nExecute the following command mvn package 13. Execute the following command to run project\njava -jar target/TripSearch-sdkClient-1.0-SNAPSHOT.jar You will see an output. The example API consumer will time how long each call to the API takes, and display the results. It will make a maximum of 100 calls as quickly as it can.\nIf we had many of these clients consuming the API rapidly, we could overwhelm the provisioned infrastructure, so we need some way of throttling calls. We can use Usage Plans to do this.\nGo to AWS API Gateway console Type iDevelop - Trip Search API to the search bar and press Enter Click iDevelop - Trip Search API Click Usage Plans Click Create In the Name section, type LabPlan In the Rate section, type 1 In the Burst section, type 1 In the Quota section, type 1000 per month Click Next Click Add API Stage In the API drop-down list, select iDevelop - Trip Search API In the Stage drop-down list, select prod Click the grey tick icon to commit the changes Click Next CLick Create API Key and add to Usage Plan In the dialog that appears, for Name type SDKClient Click Save Click Done, A new API key will be created and associated with the usage Plan. Click iDevelop - Trip Search API Click the GET method beneath /tripsfromcity/{city} Click Method Request In the API Key Required section, click the pencil edit icon Select True Click the grey tick icon to commit the change Click Actions Click Deploy API In the dialog that appears: In the Deployment stage section, select prod Click Deploy In the prod Stage Editor, click SDK Generation In the Platform section, select Java SDK In the Service name section, type TripSearch In the Java package name section, type idevelop.api.sdk Click Generate SDK. The Java SDK will be generated and downloaded as a ZIP file. Extract the ZIP file we downloaded in step 26 Open Command Prompt and navigate to the directory of the downloaded SDK has been exploded (the directory is called generated-code) Execute the following command mvn install This will compile and install the SDK in your local Maven repository, overwriting the previous version.\nTest the newly generated SDK with the Java client app Execute the following command to run application java -jar target/TripSearch-sdkClient-1.0-SNAPSHOT.jar ince you have set the /tripsfromcity/{GET} endpoint to require an API Key, but have not actually set an API in the client application, you will see a Forbidden error Set the API Key in the client code and re-run the API consumer application with throttling enabled Click API Keys Click SDKClient In the API Key section, click show to show the auto-generated API key Save the API key in the API key section In the Eclipse IDE, open the file whose the path is /src/main/java/idevelop/api/tripsearch/sdk/app/App.java Replace \u0026lt;REPLACE_WITH_API_KEY\u0026gt; with the API key value we saved in step 30 In the same file, locate the commented out call to apiKey(API_KEY) in the TripSearch builder call. You may have to run a Maven Update on the project to pick up the .apiKey as we updated the jar in the last step and Eclipse may not have picked it up. Now that you have required an API Key in the API Gateway call, the SDK created for you will contain a call to allow the key to be set. If you have no API Key requirements, the code generator does not emit this functionality so in the provided code, it is commented out. You need to enable the call in the client code to allow the API Key to be set correctly. Save In the Eclipse IDE, right-click on the TripSearch-sdkClient project Click Maven Click Update Project\u0026hellip; In the Command Prompt, execute the following command mvn package 34. In the Command Prompt, execute the following command\njava -jar target/TripSearch-sdkClient-1.0-SNAPSHOT.jar 35. You will now periodically start receiving errors requesting you slow down the call-rate. This is because we set a maximum call-rate of 1 call per second per API key. You will see a output 36. As an experiment, edit the API_KEY you have set in the App class (for example, add a period at the end) which will cause it to be invalid. Re-run the app and notice that you now receive a Forbidden message. This is because you set the API Key as required for calls to the /tripsfromcity call. 37. In the Command Prompt, execute the following command\njava -jar target/TripSearch-sdkClient-1.0-SNAPSHOT.jar You will see a output Experiment with the Rate and Burst settings in the Usage Plan to see how they affect the client app calling the API you do not need to re-deploy the API nor re-create the SDK if you change the settings in the Usage Plan.\n"},{"uri":"https://hotloncon1.github.io/aws-lab000055/6-challenge/","title":"Challenge","tags":[],"description":"","content":"Challenge \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;devlounge.lambda\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;flightspecials\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;1.8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;1.8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.6.0\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;1.8\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;1.8\u0026lt;/target\u0026gt; \u0026lt;encoding\u0026gt;UTF-8\u0026lt;/encoding\u0026gt; \u0026lt;forceJavacCompilerUse\u0026gt;true\u0026lt;/forceJavacCompilerUse\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-shade-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.0\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;createDependencyReducedPom\u0026gt;false\u0026lt;/createDependencyReducedPom\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;shade\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;artifactSet\u0026gt; \u0026lt;excludes\u0026gt; \u0026lt;exclude\u0026gt;com.amazonaws:aws-lambda-java-events\u0026lt;/exclude\u0026gt; \u0026lt;exclude\u0026gt;com.amazonaws:aws-lambda-java-core\u0026lt;/exclude\u0026gt; \u0026lt;/excludes\u0026gt; \u0026lt;/artifactSet\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.amazonaws\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aws-xray-recorder-sdk-bom\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.1\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.22\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.amazonaws\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aws-lambda-java-events\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.amazonaws\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aws-lambda-java-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.tomcat\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tomcat-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;9.0.39\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.amazonaws\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aws-xray-recorder-sdk-core\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.amazonaws\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aws-xray-recorder-sdk-apache-http\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.amazonaws\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aws-xray-recorder-sdk-aws-sdk\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.amazonaws\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aws-xray-recorder-sdk-aws-sdk-instrumentor\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.amazonaws\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aws-xray-recorder-sdk-sql-mysql\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.3.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-autoconfigure\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.3.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.json\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;json\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;20180130\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.amazonaws.serverless\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aws-serverless-java-container-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.junit.jupiter\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-jupiter-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; As an optional task, you are challenged with implementing active tracing using automation for the functions deployed using the AWS CLI and CodeStar. We are not going to give you all the answers! But to help you on your journey, check out the AWS::Lambda::Function tCloudFormation documentation, and AWS SAM documentation.\nWhen you have fully implemented tracing for the Lambda functions, you will see the tracing segments on the AWS X-ray console. Trigger the execution of the various lambda functions using the TravelBuddy SPA web page, and you will see results such as:\n"},{"uri":"https://hotloncon1.github.io/aws-lab000055/7-cleanup/","title":"Clean up resources","tags":[],"description":"","content":"You clean up resources in the following order:\nTerminate EC2 Instance Go to Amazon EC2 console. On the left navigation bar, click Intances. Select DevAxWindowsHost. Click Instance state Click Terminate instance Click Terminate Delete Users Go to AWS IAM Console. Click Users. Type awsstudent to the search bar Select awsstudent. Click Delete Type awsstudent to confirm, then click Delete Delete policy Go to AWS IAM Console. Click Policies. Type idevelop to the search bar and press Enter Select idevelopCodeStarCloudFormationPolicy Click Actions Click Delete Type the name of the policy to confirm, then click Delete to delete Delete DynamoDB Go to AWS DynamoDB Console. Click Tables Select all the DynamoDB we create Click Actions Click Delete Type delete to confirm, then click Delete to delete Delete API Gateway Go to AWS API Gateway console. Selet iDevelop - Trip Search API Click Actions Click Delete Click Delete to delete Delete CodeStar Go to AWS CodeStar Console. Click Projects Select FlightSpecialsAPI Click Delete Type delete to confirm, then click Delete to delete Delete CloudFormation Stack Go to AWS CloudFormation Console. Select DevAx-06. Click Delete Click Delete stack Do the same for the other CloudFormation Stacks Delete S3 bucket Go to AWS S3 Console. Click Buckets Select aws-codestart-us-east-1\u0026hellip;. Click Empty. Type permanently delete to confirm, then click Empty to delete the data of this S3 bucket. Click Exit to back to the S3 inteface. Click Delete. Type the name of the bucket then click Delete bucket to delete S3 bucket. Do the same for the other S3 bucket "},{"uri":"https://hotloncon1.github.io/aws-lab000055/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://hotloncon1.github.io/aws-lab000055/tags/","title":"Tags","tags":[],"description":"","content":""}]